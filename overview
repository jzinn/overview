#!/bin/sh

# shellcheck disable=SC2006
# SC2006: Use $(..) instead of legacy `..`.

set -eu

# # BSD sed lacks the -z / --zero-terminated flag.
# # BSD awk exits after one line when RS is set to "\0".
# # Therefore, we have to resort to perl -0.
# if ! command -v perl > /dev/null 2>$1
# then
# 	echo 'perl is required but not available'
# 	exit 1
# fi

main() {
	test $# -ge 1 || nope

	case "$1" in
		init | root | dotfiles | node | validate | test | debug | write | list | find | sort | html | help )
			# shellcheck disable=SC2145
			# SC2145: Argument mixes string and array.
			command_"$@"
			;;
		* )
			nope
			;;
	esac
}

nope() {
	usage >&2
	exit 1
}

die() {
	# sed "s/^/overview: $1: /" >&2
	cat >&2
	exit 1
}

usage() {
	cat <<'EOF'
Usage:
    overview init [-a] [-r] [<directory>]
    overview root [-d] [-f] [-j <n>] <directory>
    overview dotfiles [-z] <directory>
    overview node [-d] [-f] [-r] <file>
    overview validate [-q] <file>
    overview test [-q] [<expression>]
    overview debug [...]
    overview write [-f] <file> <directory> <expression>
    overview list <directory> <expression>
    overview find [-z] <directory> <expression>
    overview sort [-r] [-z]
    overview html [-z]
    overview help
EOF
}

shellquote() {
	printf -- '%s\0' "$1" |
		awk 'BEGIN{RS="\0"}{gsub(/[^0-9A-Za-z\/_.-]/,"\\\\&")}1'
}

command_help() {
	test $# -eq 0 || nope

	usage
}

command_init() {
	INIT=default

	while test $# -ne 0
	do
		case "$1" in
			-a | --all )
				INIT=all
				shift
				;;
			-r | --root )
				INIT=root
				shift
				;;
			-- )
				shift
				break
				;;
			* )
				break
				;;
		esac
	done

	test $# -eq 0 && set -- .
	test $# -eq 1 || nope

	dotfile_init_"$INIT" "$1" dotfile_contents_"$INIT"
}

dotfile_init_default() {
	init "$1/.overview" "$2"
}

dotfile_init_all() {
	init "$1/.overview-all" "$2"
}

dotfile_init_root() {
	init "$1/.overview-root" "$2"
}

init() {
	if test -e "$1"
	then
		echo "Not initializing `shellquote "$1"`: file already exists" | die
	else
		"$2" > "$1"
		echo "Initialized in `shellquote "$1"`"
	fi
}

dotfile_contents_default() {
	true
}

dotfile_contents_all() {
	printf -- '-true\n'
}

dotfile_contents_root() {
	printf -- '-name overview*.html\n'
}

# Sort the dotfiles so that if --jobs is 1
# then ancestors can find overview*.html files written by descendents.
#
# POSIX specifies that find should have a -depth option
# that causes find to do a depth-first traversal.
# Both GNU find and BSD find support -depth.
# But it does not seem to work on macOS.
#
# Instead of find -depth, we do a reverse sort.
command_root() {
	DEBUG=
	FORCE=
	JOBS=1

	while test $# -ne 0
	do
		case "$1" in
			-d | --debug )
				DEBUG=-d
				shift
				;;
			-f | --force )
				FORCE=-f
				shift
				;;
			-j | --jobs )
				shift
				JOBS="$1"
				shift
				;;
			-- )
				shift
				break
				;;
			* )
				break
				;;
		esac
	done

	test $# -eq 1 || nope

	"$0" dotfiles -z -- "$1" |
		"$0" sort -z -r |
		xargs -0 -n 1 -P "$JOBS" "$0" node $DEBUG $FORCE --no-run-if-empty --
}

command_dotfiles() {
	PRINT=-print

	while test $# -ne 0
	do
		case "$1" in
			-z | --zero-terminated )
				PRINT=-print0
				shift
				;;
			-- )
				shift
				break
				;;
			* )
				break
				;;
		esac
	done

	test $# -eq 1 || nope

	exec find "$1" -type f -name '.overview*' "$PRINT"
}

# We typically get here from a `find | xargs -n 1 node`.
# The `node` command requires one argument (a dotfile),
# but if `find` returns no results,
# then `xargs` will still call `node` one time with no arguments.
#
# GNU `find` has a `-r` / `--no-run-if-empty` flag to prevent this,
# but it is not portable.  With GNU `find`, we can write
#
#     find | xargs -n 1 --no-run-if-empty node
#
# Instead, we give `node` the `-r` / `--no-run-if-empty` flags,
# so that we can portably write
#
#     find | xargs -n 1 node --no-run-if-empty
#
command_node() {
	DEBUG=
	FORCE=
	NO_RUN_IF_EMPTY=false

	while test $# -ne 0
	do
		case "$1" in
			-d | --debug )
				DEBUG=debug
				shift
				;;
			-f | --force )
				FORCE=-f
				shift
				;;
			-r | --no-run-if-empty )
				NO_RUN_IF_EMPTY=true
				shift
				;;
			-- )
				shift
				break
				;;
			* )
				break
				;;
		esac
	done

	"$NO_RUN_IF_EMPTY" && test $# -eq 0 && return

	test $# -eq 1 || nope

	echo "Processing dotfile `shellquote "$1"`"

	if ! "$0" validate -q -- "$1"
	then
		echo 'Dotfile is invalid!  For more information, run'
		echo
		echo "    `shellquote "$0"` validate `shellquote "$1"`"
		echo
	else
		set -- "$1" "${1##*/}" "${1%/*}"
		set -- "$1" "$3/${2#.}.html" "$3"

		query "$1" | ( shift; xargs "$0" $DEBUG write $FORCE -- "$1" "$2" )
	fi
}

command_validate() {
	QUIET=false
	QUIET_FLAG=

	while test $# -ne 0
	do
		case "$1" in
			-q | --quiet )
				QUIET=true
				QUIET_FLAG=-q
				shift
				;;
			-- )
				shift
				break
				;;
			* )
				break
				;;
		esac
	done

	test $# -eq 1 || nope

	if ! test -f "$1"
	then
		echo "Not validating `shellquote "$1"`: file does not exist" | die
	fi

	if ! "$QUIET"
	then
		if grep -q '\S' "$1"
		then
			sed 's/^/Dotfile contents: /' "$1"
		else
			echo 'Dotfile is blank'
		fi
	fi

	query "$1" | xargs "$0" test $QUIET_FLAG --
}

# This is typically used via a query | xargs pipeline.
# If stdin is empty, then GNU xargs will call the command,
# but BSD xargs will not.
# So query must return something.
query() {
	if grep -q '\S' "$1"
	then
		cat "$1"
	else
		printf -- '-name *.html\n'
	fi
}

command_test() {
	QUIET=false

	while test $# -ne 0
	do
		case "$1" in
			-q | --quiet )
				QUIET=true
				shift
				;;
			-- )
				shift
				break
				;;
			* )
				break
				;;
		esac
	done

	# test $# -ge 0 || nope

	set -- find . -quit \( "$@" \)

	if ! "$QUIET"
	then
		printf -- 'Test command:'
		printf -- ' "%s"' "$@"
		printf -- '\n'
		exec "$@"
	else
		exec "$@" > /dev/null 2>&1
	fi
}

command_debug() {
	# test $# -ge 0 || nope

	printf -- 'debug:'

	if test $# -eq 0
	then
		printf -- ' No arguments'
	else
		printf -- ' "%s"' "$@"
	fi

	printf -- '\n'
}

command_write() {
	FORCE=false

	while test $# -ne 0
	do
		case "$1" in
			-f | --force )
				FORCE=true
				shift
				;;
			-- )
				shift
				break
				;;
			* )
				break
				;;
		esac
	done

	test $# -ge 2 || nope

	if ! should_write "$1" "$FORCE"
	then
		echo "Not writing `shellquote "$1"`: a file may already exist but not contain the magic string" | die
	fi

	( shift; "$0" list "$@" ) > "$1"
	echo "Wrote `shellquote "$1"`"
}

should_write() {
	! test -e "$1" || { test -f "$1" && { "$2" || has_magic < "$1"; }; }
}

has_magic() {
	head | grep -q "keebee3eing9iem6chiepourooSiequ8ezookaewoocoh0aophei4EeSh5auheij"
}

command_list() {
	test $# -ge 2 || nope

	"$0" find -z -- "$@" | "$0" sort -z | "$0" html -z
}

command_find() {
	PRINT=-print

	while test $# -ne 0
	do
		case "$1" in
			-z | --zero-terminated )
				PRINT=-print0
				shift
				;;
			-- )
				shift
				break
				;;
			* )
				break
				;;
		esac
	done

	test $# -ge 2 || nope

	cd "$1"
	shift

	exec find . -mindepth 2 -type f \( "$@" \) "$PRINT"
}

command_sort() {
	REVERSE=
	Z=0
	ZERO_TERMINATED=

	while test $# -ne 0
	do
		case "$1" in
			-r | --reverse )
				REVERSE=-r
				shift
				;;
			-z | --zero-terminated )
				Z=1
				ZERO_TERMINATED=-z
				shift
				;;
			-- )
				shift
				break
				;;
			* )
				break
				;;
		esac
	done

	test $# -eq 0 || nope

	# GNU sed has a -z option, but BSD sed does not.
	# Use awk instead.

	# Double up the last /, then sort, then remove the extra /.
	awk -v Z="$Z" 'BEGIN{if(Z)ORS=RS="\0"}{sub(/^.*\//,"&/")}1' |
		sort -t / $REVERSE $ZERO_TERMINATED |
		awk -v Z="$Z" 'BEGIN{if(Z)ORS=RS="\0"}{sub(/\/\//,"/")}1'
}

command_html() {
	ZERO_TERMINATED=0

	while test $# -ne 0
	do
		case "$1" in
			-z | --zero-terminated )
				ZERO_TERMINATED=1
				shift
				;;
			-- )
				shift
				break
				;;
			* )
				break
				;;
		esac
	done

	test $# -eq 0 || nope

	# shellcheck disable=SC2016
	# SC2016: Expressions don't expand in single quotes, use double quotes for that.
	exec awk -v ZERO_TERMINATED="$ZERO_TERMINATED" '
BEGIN {
	if (ZERO_TERMINATED)
		RS = "\0"
	OFS = FS = "/"
	print "<!doctype html>"
	print "<!-- keebee3eing9iem6chiepourooSiequ8ezookaewoocoh0aophei4EeSh5auheij -->"
	print "<html lang=\"en\">"
	print "<head>"
	print "  <meta charset=\"utf-8\">"
	print "  <title>Overview</title>"
	print "  <style>"
	print "    body {"
	print "      font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";"
	print "    }"
	print "    main {"
	print "      font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;"
	print "    }"
	print "  </style>"
	print "</head>"
	print "<body>"
	print "  <h1>Overview</h1>"
	print "  <main>"
	print "    <ol>"
}

END {
	iteration_end()
	print ""
	print "    </ol>"
	print "    <p>" NR " files</p>"
	print "  </main>"
	print "</body>"
	print "</html>"
}

{ process() }

function process(    url, name, title) {
	url = $0
	name = $NF
	$NF = ""
	title = $0

	iteration_middle(title)
	item(url, name)
}

function iteration_middle(title) {
	if (iteration_changed(title))
		iteration_tick(title)
}

function iteration_changed(title,    eq) {
	eq = title == PREVIOUS
	PREVIOUS = title
	return !eq
}

function iteration_tick(title) {
	if (NR != 1)
		section_close()
	section_open(title)
}

function iteration_end() {
	if (NR)
		section_close()
}

function section_open(title) {
	print ""
	print "      <li>"
	print "        <h3>" title "</h3>"
	print "        <ol>"
}

function section_close() {
	print "        </ol>"
	print "      </li>"
}

function item(url, name) {
	print "          <li><a href=\"" url "\">" name "</a></li>"
}
'
}

main "$@"
