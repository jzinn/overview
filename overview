#!/bin/sh
set -eu

# set -x

# test -n "${BASH:-}" && set -o pipefail -o posix

main() {
	test $# -ge 1 || nope

	case "$1" in
		init | tree | dotfiles | node | validate | debug | write | generate | find | sort | html | help )
			# shellcheck disable=SC2145
			command_"$@"
			;;
		* )
			nope
			;;
	esac
}

nope() {
	usage >&2
	exit 1
}

die() {
	# sed "s/^/overview: $1: /" >&2
	cat >&2
	exit 1
}

usage() {
	cat <<'EOF'
Usage:
    overview init [<directory>]
    overview tree [-d] [-f] [-j <n>] <directory>
    overview dotfiles [-z] <directory>
    overview node [-d] [-f] [-r] <file>
    overview debug [...]
    overview write [-f] <file> <directory> <expression>
    overview generate <directory> <expression>
    overview find [-z] <directory> <expression>
    overview sort [-r] [-z]
    overview html [-z]
    overview help
EOF
}

command_help() {
	test $# -eq 0 || nope

	usage
}

command_init() {
	test $# -eq 0 && set -- .
	test $# -eq 1 || nope
	set -- "$1/.overview"

	if test -e "$1"
	then
		echo "Not initializing \"$1\": file already exists"
	else
		touch "$1"
		echo "Initialized in \"$1\""
	fi
}

# Sort the dotfiles so that if --jobs is 1
# then ancestors can find overview*.html files written by descendents.
#
# POSIX specifies that find should have a -depth option
# that causes find to do a depth-first traversal.
# Both GNU find and BSD find support -depth.
# But it does not seem to work on macOS.
#
# Instead of find -depth, we do a reverse sort.
command_tree() {
	DEBUG=
	FORCE=
	JOBS=1

	while test $# -ne 0
	do
		case "$1" in
			-d | --debug )
				DEBUG=-d
				shift
				;;
			-f | --force )
				FORCE=-f
				shift
				;;
			-j | --jobs )
				shift
				JOBS="$1"
				shift
				;;
			* )
				break
				;;
		esac
	done

	test $# -eq 1 || nope

	"$0" dotfiles -z "$1" |
		"$0" sort -z -r |
		xargs -0 -n 1 -P "$JOBS" "$0" node $DEBUG $FORCE --no-run-if-empty
}

command_dotfiles() {
	PRINT=-print

	while test $# -ne 0
	do
		case "$1" in
			-z | --zero-terminated )
				PRINT=-print0
				shift
				;;
			* )
				break
				;;
		esac
	done

	exec find "$1" -type f -name '.overview*' "$PRINT"
}

# We typically get here from a `find | xargs -n 1 node`.
# The `node` command requires one argument (a dotfile),
# but if `find` returns no results,
# then `xargs` will still call `node` one time with no arguments.
#
# GNU `find` has a `-r` / `--no-run-if-empty` flag to prevent this,
# but it is not portable.  With GNU `find`, we can write
#
#     find | xargs -n 1 --no-run-if-empty node
#
# Instead, we give `node` the `-r` / `--no-run-if-empty` flags,
# so that we can portably write
#
#     find | xargs -n 1 node --no-run-if-empty
#
command_node() {
	DEBUG=
	FORCE=
	NO_RUN_IF_EMPTY=false

	while test $# -ne 0
	do
		case "$1" in
			-d | --debug )
				DEBUG=debug
				shift
				;;
			-f | --force )
				FORCE=-f
				shift
				;;
			-r | --no-run-if-empty )
				NO_RUN_IF_EMPTY=true
				shift
				;;
			* )
				break
				;;
		esac
	done

	"$NO_RUN_IF_EMPTY" && test $# -eq 0 && return

	test $# -eq 1 || nope

	echo "Processing dotfile \"$1\""

	set -- "$1" "${1##*/}" "${1%/*}"
	set -- "$1" "$3/${2#.}.html" "$3"

	# If stdin is empty, then GNU xargs will call the command,
	# but BSD xargs will not.
	# So query must return something.
	if ! query < "$1" | xargs "$0" validate
	then
		echo 'Dotfile is invalid!'
	else
		( shift; query | xargs "$0" $DEBUG write $FORCE "$1" "$2" ) < "$1"
	fi
}

query() {
	# grep --passthrough '\S', if grep supported --passthrough
	awk '/\S/{m=1}END{exit!m}1' || printf -- '-name *.html\n'
}

command_validate() {
	exec find . -quit \( "$@" \) > /dev/null 2>&1
}

command_debug() {
	printf debug:

	if test $# -eq 0
	then
		printf ' No arguments'
	else
		printf ' "%s"' "$@"
	fi

	printf '\n'
}

command_write() {
	FORCE=false

	while test $# -ne 0
	do
		case "$1" in
			-f | --force )
				FORCE=true
				shift
				;;
			* )
				break
				;;
		esac
	done

	test $# -ge 2 || nope

	if ! should_write "$1" "$FORCE"
	then
		echo "Not writing \"$1\": a file may already exist but not contain the magic string" | die
	fi

	( shift; "$0" generate "$@" ) > "$1"
	echo "Wrote \"$1\""
}

should_write() {
	! test -e "$1" || { test -f "$1" && { "$2" || has_magic < "$1"; }; }
}

has_magic() {
	head | grep -q "keebee3eing9iem6chiepourooSiequ8ezookaewoocoh0aophei4EeSh5auheij"
}

command_generate() {
	test $# -ge 1 || nope

	"$0" find -z "$@" | "$0" sort -z | "$0" html -z
}

command_find() {
	PRINT=-print

	while test $# -ne 0
	do
		case "$1" in
			-z | --zero-terminated )
				PRINT=-print0
				shift
				;;
			* )
				break
				;;
		esac
	done

	test $# -ge 2 || nope

	cd "$1"
	shift

	exec find . -mindepth 2 -type f \( "$@" \) "$PRINT"
}

# Argh! I want to sort first on directory, and then by file name.
# I need
#
#     sort -t / -k 1,-1 -k -1
#
# Too bad sort doesn't allow negative indexes to count from the end.
# Also -1 looks like a flag.
command_sort() {
	REVERSE=
	Z=0
	ZERO_TERMINATED=

	while test $# -ne 0
	do
		case "$1" in
			-r | --reverse )
				REVERSE=-r
				shift
				;;
			-z | --zero-terminated )
				Z=1
				ZERO_TERMINATED=-z
				shift
				;;
			* )
				break
				;;
		esac
	done

	# GNU sed has a -z option, but BSD sed does not.
	# Use awk instead.

	# Double up the last /, then sort, then remove the extra /.
	awk -v Z="$Z" 'BEGIN{if(Z)ORS=RS="\0"}{sub(/^.*\//,"&/")}1' |
		sort -t / $REVERSE $ZERO_TERMINATED |
		awk -v Z="$Z" 'BEGIN{if(Z)ORS=RS="\0"}{sub(/\/\//,"/")}1'
}

command_html() {
	ZERO_TERMINATED=0

	while test $# -ne 0
	do
		case "$1" in
			-z | --zero-terminated )
				ZERO_TERMINATED=1
				shift
				;;
			* )
				break
				;;
		esac
	done

	test $# -eq 0 || nope

	awk -v ZERO_TERMINATED="$ZERO_TERMINATED" '
BEGIN {
	if (ZERO_TERMINATED)
		RS = "\0"
	OFS = FS = "/"
	print "<!doctype html>"
	print "<!-- keebee3eing9iem6chiepourooSiequ8ezookaewoocoh0aophei4EeSh5auheij -->"
	print "<html lang=\"en\">"
	print "<head>"
	print "  <meta charset=\"utf-8\">"
	print "  <title>Overview</title>"
	print "  <style>"
	print "    body {"
	print "      font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";"
	print "    }"
	print "    main {"
	print "      font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;"
	print "    }"
	print "  </style>"
	print "</head>"
	print "<body>"
	print "  <h1>Overview</h1>"
	print "  <main>"
	print "    <ol>"
}

END {
	iteration_end()
	print ""
	print "    </ol>"
	print "  </main>"
	print "</body>"
	print "</html>"
}

{ process() }

function process(    url, name, title) {
	url = $0
	name = $NF
	$NF = ""
	title = $0

	iteration_middle(title)
	item(url, name)
}

function iteration_middle(title) {
	if (iteration_changed(title))
		iteration_tick(title)
}

function iteration_changed(title,    eq) {
	eq = title == PREVIOUS
	PREVIOUS = title
	return !eq
}

function iteration_tick(title) {
	if (NR != 1)
		section_close()
	section_open(title)
}

function iteration_end() {
	if (NR)
		section_close()
}

function section_open(title) {
	print ""
	print "      <li>"
	print "        <h3>" title "</h3>"
	print "        <ol>"
}

function section_close() {
	print "        </ol>"
	print "      </li>"
}

function item(url, name) {
	print "          <li><a href=\"" url "\">" name "</a></li>"
}
'
}

main "$@"
